<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SmallRye Reactive Messaging</title>
    <meta name="generator" content="Antora 2.3.0-beta.1">
    <link rel="stylesheet" href="../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">SmallRye Reactive Messaging</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Project</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://github.com/smallrye/smallrye-reactive-messaging">Source Code</a>
            <a class="navbar-item" href="https://github.com/smallrye/smallrye-reactive-messaging/issues">Issue Tracker</a>
          </div>
        </div>
        <a class="navbar-item" href="https://smallrye.io/" alt=>A SmallRye.io Project</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="smallrye-reactive-messaging" data-version="3.3">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">SmallRye Reactive Messaging</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../getting-started.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../concepts.html">Concepts</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepts.html#messages">Messages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepts.html#channels">Channels</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepts.html#connectors">Connectors</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../model/model.html">Development Model</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#overview">Incoming and Outgoing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#messages">Creating Messages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#generating-messages">Generating messages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#generating-payloads">Generating payloads</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#consuming-messages">Consuming messages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#consuming-payloads">Consuming payloads</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#processing-messages">Processing messages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#processing-payloads">Processing payloads</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#processing-streams">Processing streams</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#skipping">Skipping messages or payloads</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../model/model.html#converters">Converting messages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../acknowledgement/acknowledgement.html">Acknowledgement</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../advanced/broadcast.html">Broadcasting</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../advanced/merge.html">Merging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../advanced/incomings.html">Multiple @Incoming</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../advanced/blocking.html">Handling blocking execution</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../signatures/signatures.html">Method signatures</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../connectors/connectors.html">Connectors</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="kafka.html">Apache Kafka</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kafka.html#kafka-installation">Using the connector</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kafka.html#kafka-inbound">Receiving Kafka Records</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kafka.html#kafka-outbound">Writing Kafka Records</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kafka.html#kafka-health">Health Check</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kafka.html#kafka-avro-configuration">Using Avro</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../amqp/amqp.html">AMQP</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../amqp/amqp.html#amqp-installation">Using the connector</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../amqp/amqp.html#amqp-inbound">Receiving AMQP Messages</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../amqp/amqp.html#amqp-outbound">Sending AMQP Messages</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../amqp/amqp.html#amqp-customization">Configuring the client</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../amqp/amqp.html#amqp-health">Health Check</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../amqp/amqp.html#amqp-rabbitmq">Connecting with RabbitMQ</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../camel/camel.html">Apache Camel</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../camel/camel.html#camel-installation">Using the connector</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../camel/camel.html#camel-inbound">Receiving data using Camel</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../camel/camel.html#camel-outbound">Sending data using Camel</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../camel/camel.html#camel-api">Using existing routes</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../jms/jms.html">JMS</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../jms/jms.html#jms-installation">Using the connector</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../jms/jms.html#jms-inbound">Receiving JMS Messages</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../jms/jms.html#jms-outbound">Sending JMS Messages</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../jms/jms.html#jms-configuration">Advanced configuration</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../mqtt/mqtt.html">MQTT</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../mqtt/mqtt.html#mqtt-installation">Using the connector</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../mqtt/mqtt.html#mqtt-inbound">Receiving MQTT Messages</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../mqtt/mqtt.html#mqtt-outbound">Sending MQTT Messages</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#mqtt-server:mqtt-server.adoc">Exposing an MQTT server</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../emitter/emitter.html">Emitters and Channels</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../emitter/emitter.html#emitter-payloads">Sending payloads</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../emitter/emitter.html#emitter-messages">Sending messages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../emitter/emitter.html#emitter-overflow">Managing overflow</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../emitter/emitter.html#streams">Injecting channels</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../testing/testing.html">Testing applications</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../advanced/advanced.html">Advanced topics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../advanced/advanced.html#logging">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../advanced/advanced.html#strict">Strict mode</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<!-- This is the default navigation panel in the bottom left corner. We aren't using it, but let's keep it commented out
    should we change our minds about it -->
<!--
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">SmallRye Reactive Messaging</span>
    <span class="version">3.3</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">SmallRye Reactive Messaging</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">3.3</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
-->
    </div>
  </aside>
</div>
<main>
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
</div>
<article class="doc">
<div class="sect1">
<h2 id="kafka-inbound"><a class="anchor" href="#kafka-inbound"></a>Receiving Kafka Records</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Kafka Connector retrieves Kafka Records from Kafka Brokers and maps each of them to Reactive Messaging <code>Messages</code>.</p>
</div>
<div class="sect2">
<h3 id="_example"><a class="anchor" href="#_example"></a>Example</h3>
<div class="paragraph">
<p>Let&#8217;s imagine you have a Kafka broker running, and accessible using the <code>kafka:9092</code> address (by default it would use <code>localhost:9092</code>).
Configure your application to receive Kafka records from a Kafka <em>topic</em> on the <code>prices</code> channel as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>kafka.bootstrap.servers=kafka:9092      <i class="conum" data-value="1"></i><b>(1)</b>

mp.messaging.incoming.prices.connector=smallrye-kafka       <i class="conum" data-value="2"></i><b>(2)</b>
mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.DoubleDeserializer    <i class="conum" data-value="3"></i><b>(3)</b>
mp.messaging.incoming.prices.broadcast=true     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Configure the broker location. You can configure it globally or per channel</p>
</li>
<li>
<p>Configure the connector to manage the <code>prices</code> channel</p>
</li>
<li>
<p>Sets the (Kafka) deserializer to read the record&#8217;s value</p>
</li>
<li>
<p>Make sure that we can receive from more that one consumer (see <code>KafkaPriceConsumer</code> and <code>KafkaPriceMessageConsumer</code> below)</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You don&#8217;t need to set the Kafka topic. By default, it uses the channel name (<code>prices</code>). You can configure the <code>topic</code> attribute to override it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then, your application receives <code>Message&lt;Double&gt;</code>.
You can consume the payload directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package inbound;

import org.eclipse.microprofile.reactive.messaging.Incoming;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class KafkaPriceConsumer {

    @Incoming("prices")
    public void consume(double price) {
        // process your price.
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, you can retrieve the <code>Message&lt;Double&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package inbound;

import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Message;

import javax.enterprise.context.ApplicationScoped;
import java.util.concurrent.CompletionStage;

@ApplicationScoped
public class KafkaPriceMessageConsumer {

    @Incoming("prices")
    public CompletionStage&lt;Void&gt; consume(Message&lt;Double&gt; price) {
        // process your price.

        // Acknowledge the incoming message (commit the offset)
        return price.ack();
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deserialization"><a class="anchor" href="#_deserialization"></a>Deserialization</h3>
<div class="paragraph">
<p>The deserialization is handled by the underlying Kafka Client.
You need to configure the:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mp.messaging.incoming.[channel-name].value.deserializer</code> to configure the value deserializer (mandatory)</p>
</li>
<li>
<p><code>mp.messaging.incoming.[channel-name].key.deserializer</code> to configure the key deserializer (optional, default to <code>String</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want to use a custom deserializer, add it to your <code>CLASSPATH</code> and configure the associate attribute.</p>
</div>
<div class="paragraph">
<p>In addition, the Kafka Connector also provides a set of <em>message converters</em>.
So you can receive <em>payloads</em> representing records from Kafka using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://smallrye.io/smallrye-reactive-messaging/3.3.0/apidocs/io/smallrye/reactive/messaging/kafka/Record.html">Record&lt;K,V&gt;</a> - a pair key/value</p>
</li>
<li>
<p><a href="https://kafka.apache.org/26/javadoc/index.html?org/apache/kafka/clients/consumer/ConsumerRecord.html">ConsumerRecord&lt;K,V&gt;</a> - a structure representing the record with all its metadata</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("topic-a")
public void consume(Record&lt;String, String&gt; record) {
    String key = record.key(); // Can be `null` if the incoming record has no key
    String value = record.value(); // Can be `null` if the incoming record has no value
}

@Incoming("topic-b")
public void consume(ConsumerRecord&lt;String, String&gt; record) {
    String key = record.key(); // Can be `null` if the incoming record has no key
    String value = record.value(); // Can be `null` if the incoming record has no value
    String topic = record.topic();
    int partition = record.partition();
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_inbound_metadata"><a class="anchor" href="#_inbound_metadata"></a>Inbound Metadata</h3>
<div class="paragraph">
<p>Messages coming from Kafka contains an instance of <a href="https://smallrye.io/smallrye-reactive-messaging/3.3.0/apidocs/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecordMetadata.html">IncomingKafkaRecordMetadata&lt;K, T&gt;</a> in the metadata.
<code>K</code> is the type of the record&#8217;s key.
<code>T</code> is the type of the record&#8217;s value.
It provides the key, topic, partitions, headers and so on:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IncomingKafkaRecordMetadata&lt;String, Double&gt; metadata = incoming.getMetadata(IncomingKafkaRecordMetadata.class)
    .orElse(null);
if (metadata != null) {
    // The topic
    String topic = metadata.getTopic();

    // The key
    String key = metadata.getKey();

    // The timestamp
    Instant timestamp = metadata.getTimestamp();

    // The underlying record
    ConsumerRecord&lt;String, Double&gt; record = metadata.getRecord();

    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_acknowledgement"><a class="anchor" href="#_acknowledgement"></a>Acknowledgement</h3>
<div class="paragraph">
<p>When a message produced from a Kafka record is acknowledged, the connector invokes a <em>commit strategy</em>.
These strategies decide when the consumer offset for a specific topic/partition is committed.
Committing an offset indicates that all previous records have been processed.
It is also the position where the application would restart the processing after a crash recovery or a restart.</p>
</div>
<div class="paragraph">
<p>Committing every offset has performance penalties as Kafka offset management can be slow.
However, not committing the offset often enough may lead to message duplication if the application crashes between two commits.</p>
</div>
<div class="paragraph">
<p>The Kafka connector supports three strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>throttled</code> keeps track of received messages and commit to the next offset after the latest <em>acked</em> message in sequence.
This strategy guarantees <em>at-least-once delivery</em> even if the channel performs asynchronous processing.
The connector tracks the received records and periodically (period specified by <code>auto.commit.interval.ms</code> (default: 5000)) commits the highest consecutive offset.
The connector will be marked as unhealthy if a message associated with a record is not acknowledged in <code>throttled.unprocessed-record-max-age.ms</code> (default: 60000).
Indeed, this strategy cannot commit the offset as soon as a single record processing fails (see failure-strategy to configure what happens on failing processing).
If <code>throttled.unprocessed-record-max-age.ms</code> is set to less than or equal to 0, it does not perform any health check verification. Such a setting might lead to running out of memory if there are poison pill messages.
This strategy is the default if <code>enable.auto.commit</code> is not explicitly set to <code>true</code>.</p>
</li>
<li>
<p><code>latest</code> commits the record offset received by the Kafka consumer as soon as the associated message is acknowledged (if the offset is higher than the previously committed offset).
This strategy provides <em>at-least-once</em> delivery if the channel processes the message without performing any asynchronous processing.
This strategy should not be used on high-load as offset commit is expensive.
However, it reduces the risk of duplicates.</p>
</li>
<li>
<p><code>ignore</code> performs no commit.
This strategy is the default strategy when the consumer is explicitly configured with <code>enable.auto.commit</code> to <code>true</code>.
It delegates the offset commit to the Kafka client.
This strategy provides <em>at-least-once delivery</em> if the channel processes the message without performing any asynchronous operations and when <code>enable.auto.commit</code> is set to <code>true</code>.
However, if the processing failed between two commits, messages received after the commit and before the failure will be re-processed.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The Kafka connector disables the Kafka <em>auto commit</em> is not explicitly enabled.
This behavior differs from the traditional Kafka consumer.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If high-throughout is important for you, and not limited by the downstream, we recommend to either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <code>throttled</code> policy</p>
</li>
<li>
<p>or set <code>enable.auto.commit</code> to <code>true</code> and annotate the consuming method with <code>@Acknowledgment(Acknowledgment.Strategy.NONE)</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_failure_management"><a class="anchor" href="#_failure_management"></a>Failure Management</h3>
<div class="paragraph">
<p>If a message produced from a Kafka record is <em>nacked</em>, a failure strategy is applied.
The Kafka connector supports 3 strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fail</code> - fail the application, no more records will be processed. (default)
The offset of the record that has not been processed correctly is not committed.</p>
</li>
<li>
<p><code>ignore</code> - the failure is logged, but the processing continue.
The offset of the record that has not been processed correctly is committed.</p>
</li>
<li>
<p><code>dead-letter-queue</code> - the offset of the record that has not been processed correctly is committed, but the record is written to a (Kafka) <em>dead letter queue</em> topic.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The strategy is selected using the <code>failure-strategy</code> attribute.</p>
</div>
<div class="paragraph">
<p>In the case of <code>dead-letter-queue</code>, you can configure the following attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dead-letter-queue.topic</code>: the topic to use to write the records not processed correctly, default is <code>dead-letter-topic-$channel</code>, with <code>$channel</code> being the name of the channel.</p>
</li>
<li>
<p><code>dead-letter-queue.key.serializer</code>: the serializer used to write the record key on the dead letter queue. By default, it deduces the serializer from the key deserializer.</p>
</li>
<li>
<p><code>dead-letter-queue.value.serializer</code>: the serializer used to write the record value on the dead letter queue. By default, it deduces the serializer from the value deserializer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The record written on the dead letter topic contains the original record&#8217;s headers, as well as a set of additional headers about the original record:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dead-letter-reason</code> - the reason of the failure (the <code>Throwable</code> passed to <code>nack()</code>)</p>
</li>
<li>
<p><code>dead-letter-cause</code> - the cause of the failure (the <code>getCause()</code> of the <code>Throwable</code> passed to <code>nack()</code>), if any</p>
</li>
<li>
<p><code>dead-letter-topic</code> - the original topic of the record</p>
</li>
<li>
<p><code>dead-letter-partition</code> - the original partition of the record (integer mapped to String)</p>
</li>
<li>
<p><code>dead-letter-offset</code> - the original offset of the record (long mapped to String)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using <code>dead-letter-queue</code>, it is also possible to change some metadata of the record that is sent to the dead letter topic.
To do that, use the <code>Message.nack(Throwable, Metadata)</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("in")
public CompletionStage&lt;Void&gt; consume(KafkaRecord&lt;String, String&gt; message) {
    return message.nack(new Exception("Failed!"), Metadata.of(
        OutgoingKafkaRecordMetadata.builder()
            .withKey("failed-record")
            .withHeaders(new RecordHeaders()
                .add("my-header", "my-header-value".getBytes(StandardCharsets.UTF_8))
            )
    ));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Metadata</code> may contain an instance of <code>OutgoingKafkaRecordMetadata</code>.
If the instance is present, the following properties will be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>key; if not present, the original record&#8217;s key will be used</p>
</li>
<li>
<p>topic; if not present, the configured dead letter topic will be used</p>
</li>
<li>
<p>partition; if not present, partition will be assigned automatically</p>
</li>
<li>
<p>headers; combined with the original record&#8217;s headers, as well as the <code>dead-letter-*</code> headers described above</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_handling_deserialization_failures"><a class="anchor" href="#_handling_deserialization_failures"></a>Handling deserialization failures</h3>
<div class="paragraph">
<p>Because deserialization happens before creating a <code>Message</code>, the failure strategy presented above cannot be applied.
However, when a deserialization failure occurs, you can intercept it and provide a fallback value.
If you don&#8217;t, <code>null</code> will be used as fallback value.</p>
</div>
<div class="paragraph">
<p>To achieve this, create a CDI bean implementing the <a href="https://smallrye.io/smallrye-reactive-messaging/3.3.0/apidocs/io/smallrye/reactive/messaging/kafka/DeserializationFailureHandler.html">DeserializationFailureHandler&lt;T&gt;</a> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@Identifier("failure-fallback") // Set the name of the failure handler
public class MyDeserializationFailureHandler
    implements DeserializationFailureHandler&lt;JsonObject&gt; { // Specify the expected type

    @Override
    public JsonObject handleDeserializationFailure(String topic, boolean isKey,
            String deserializer, byte[] data,
            Exception exception, Headers headers) {
        return fallback;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean must be exposed with the <code>@Identifier</code> qualifier specifying the name of the bean.
Then, in the connector configuration, specify the following attribute:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mp.messaging.incoming.$channel.key-deserialization-failure-handler</code>: name of the bean handling deserialization failures happening for the record&#8217;s key</p>
</li>
<li>
<p><code>mp.messaging.incoming.$channel.value-deserialization-failure-handler</code>: name of the bean handling deserialization failures happening for the record&#8217;s value,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The handler is called with the record&#8217;s topic, a boolean indicating whether the failure happened on a key, the class name of the deserializer that throws the exception, the corrupted data, the exception, and the records headers augmented with headers describing the failure (which ease the write to a dead letter).
The handler can return <code>null</code> (which would be as if there were no handlers).
However, if the handler throws an exception, the application would be marked unhealthy.</p>
</div>
</div>
<div class="sect2">
<h3 id="_receiving_cloud_events"><a class="anchor" href="#_receiving_cloud_events"></a>Receiving Cloud Events</h3>
<div class="paragraph">
<p>The Kafka connector supports <a href="https://cloudevents.io/">Cloud Events</a>.
When the connector detects a <em>structured</em> or <em>binary</em> Cloud Events, it adds a  <a href="https://smallrye.io/smallrye-reactive-messaging/3.3.0/apidocs/io/smallrye/reactive/messaging/kafka/IncomingKafkaCloudEventMetadata.html">IncomingKafkaCloudEventMetadata&lt;K, T&gt;</a> in the metadata of the Message.
<code>IncomingKafkaCloudEventMetadata</code> contains the various (mandatory and optional) Cloud Event attributes.</p>
</div>
<div class="paragraph">
<p>If the connector cannot extract the Cloud Event metadata, it sends the Message without the metadata.</p>
</div>
<div class="sect3">
<h4 id="_binary_cloud_events"><a class="anchor" href="#_binary_cloud_events"></a>Binary Cloud Events</h4>
<div class="paragraph">
<p>For <code>binary</code> Cloud Events, <strong>all</strong> mandatory Cloud Event attributes must be set in the record header, prefixed by <code>ce_</code> (as mandated by the <a href="https://github.com/cloudevents/spec/blob/v1.0/kafka-protocol-binding.md">protocol binding</a>).
The connector considers headers starting with the <code>ce_</code> prefix but not listed in the specification as extensions.
You can access them using the <code>getExtension</code> method from <code>IncomingKafkaCloudEventMetadata</code>.
You can retrieve them as <code>String</code>.</p>
</div>
<div class="paragraph">
<p>The <code>datacontenttype</code> attribute is mapped to the <code>content-type</code> header of the record.
The <code>partitionkey</code> attribute is mapped to the record&#8217;s key, if any.</p>
</div>
<div class="paragraph">
<p>Note that all headers are read as UTF-8.</p>
</div>
<div class="paragraph">
<p>With binary Cloud Events, the record&#8217;s key and value can use any deserializer.</p>
</div>
</div>
<div class="sect3">
<h4 id="_structured_cloud_events"><a class="anchor" href="#_structured_cloud_events"></a>Structured Cloud Events</h4>
<div class="paragraph">
<p>For <code>structured</code> Cloud Events, the event is encoded in the record&#8217;s value.
Only JSON is supported, so your event must be encoded as JSON in the record&#8217;s value.</p>
</div>
<div class="paragraph">
<p>Structured Cloud Event must set the <code>content-type</code> header of the record to <code>application/cloudevents</code> or prefix the value with <code>application/cloudevents</code> such as: <code>application/cloudevents+json; charset=UTF-8</code>.</p>
</div>
<div class="paragraph">
<p>To receive structured Cloud Events, your value deserializer must be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.apache.kafka.common.serialization.StringDeserializer</code></p>
</li>
<li>
<p><code>org.apache.kafka.common.serialization.ByteArrayDeserializer</code></p>
</li>
<li>
<p><code>io.vertx.kafka.client.serialization.JsonObjectDeserializer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As mentioned previously, the value must be a valid JSON object containing at least all the mandatory Cloud Events attributes.</p>
</div>
<div class="paragraph">
<p>If the record is a structured Cloud Event, the created Message&#8217;s payload is the Cloud Event <code>data</code>.</p>
</div>
<div class="paragraph">
<p>The <code>partitionkey</code> attribute is mapped to the record&#8217;s key if any.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuration_reference"><a class="anchor" href="#_configuration_reference"></a>Configuration Reference</h3>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Incoming Attributes of the 'smallrye-kafka' connector</caption>
<colgroup>
<col style="width: 27.7777%;">
<col style="width: 33.3333%;">
<col style="width: 16.6666%;">
<col style="width: 22.2224%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute (<em>alias</em>)</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Mandatory</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>bootstrap.servers</strong></p>
<p class="tableblock"><em>(kafka.bootstrap.servers)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A comma-separated list of host:port to use for establishing the initial connection to the Kafka cluster.</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>localhost:9092</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>topic</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The consumed / populated Kafka topic. If neither this property nor the <code>topics</code> properties are set, the channel name is used</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>health-enabled</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether health reporting is enabled (default) or disabled</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>health-readiness-enabled</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether readiness health reporting is enabled (default) or disabled</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>health-readiness-topic-verification</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the readiness check should verify that topics exist on the broker. Default to false. Enabling it requires an admin connection.</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>health-readiness-timeout</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">During the readiness health check, the connector connects to the broker and retrieves the list of topics. This attribute specifies the maximum duration (in ms) for the retrieval. If exceeded, the channel is considered not-ready.</p>
<p class="tableblock">Type: <em>long</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>tracing-enabled</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether tracing is enabled (default) or disabled</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>cloud-events</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables (default) or disables the Cloud Event support. If enabled on an <em>incoming</em> channel, the connector analyzes the incoming records and try to create Cloud Event metadata. If enabled on an <em>outgoing</em>, the connector sends the outgoing messages as Cloud Event if the message includes Cloud Event Metadata.</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>topics</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A comma-separating list of topics to be consumed. Cannot be used with the <code>topic</code> or <code>pattern</code> properties</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>pattern</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicate that the <code>topic</code> property is a regular expression. Must be used with the <code>topic</code> property. Cannot be used with the <code>topics</code> property</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>key.deserializer</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The deserializer classname used to deserialize the record&#8217;s key</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.apache.kafka.common.serialization.StringDeserializer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>value.deserializer</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The deserializer classname used to deserialize the record&#8217;s value</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>fetch.min.bytes</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The minimum amount of data the server should return for a fetch request. The default setting of 1 byte means that fetch requests are answered as soon as a single byte of data is available or the fetch request times out waiting for data to arrive.</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>group.id</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unique string that identifies the consumer group the application belongs to. If not set, a unique, generated id is used</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>enable.auto.commit</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If enabled, consumer&#8217;s offset will be periodically committed in the background by the underlying Kafka client, ignoring the actual processing outcome of the records. It is recommended to NOT enable this setting and let Reactive Messaging handles the commit.</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>retry</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not the connection to the broker is re-attempted in case of failure</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>retry-attempts</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of reconnection before failing. -1 means infinite retry</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>retry-max-wait</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The max delay (in seconds) between 2 reconnects</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>30</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>broadcast</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the Kafka records should be dispatched to multiple consumer</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>auto.offset.reset</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">What to do when there is no initial offset in Kafka.Accepted values are earliest, latest and none</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>latest</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>failure-strategy</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specify the failure strategy to apply when a message produced from a record is acknowledged negatively (nack). Values can be <code>fail</code> (default), <code>ignore</code>, or <code>dead-letter-queue</code></p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fail</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>commit-strategy</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specify the commit strategy to apply when a message produced from a record is acknowledged. Values can be <code>latest</code>, <code>ignore</code> or <code>throttled</code>. If <code>enable.auto.commit</code> is true then the default is <code>ignore</code> otherwise it is <code>throttled</code></p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>throttled.unprocessed-record-max-age.ms</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">While using the <code>throttled</code> commit-strategy, specify the max age in milliseconds that an unprocessed message can be before the connector is marked as unhealthy.</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>60000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dead-letter-queue.topic</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When the <code>failure-strategy</code> is set to <code>dead-letter-queue</code> indicates on which topic the record is sent. Defaults is <code>dead-letter-topic-$channel</code></p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dead-letter-queue.key.serializer</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When the <code>failure-strategy</code> is set to <code>dead-letter-queue</code> indicates the key serializer to use. If not set the serializer associated to the key deserializer is used</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dead-letter-queue.value.serializer</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When the <code>failure-strategy</code> is set to <code>dead-letter-queue</code> indicates the value serializer to use. If not set the serializer associated to the value deserializer is used</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitions</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of partitions to be consumed concurrently. The connector creates the specified amount of Kafka consumers. It should match the number of partition of the targeted topic</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>consumer-rebalance-listener.name</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name set in <code>@Identifier</code> of a bean that implements <code>io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener</code>. If set, this rebalance listener is applied to the consumer.</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>key-deserialization-failure-handler</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name set in <code>@Identifier</code> of a bean that implements <code>io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler</code>. If set, deserialization failure happening when deserializing keys are delegated to this handler which may provide a fallback value.</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>value-deserialization-failure-handler</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name set in <code>@Identifier</code> of a bean that implements <code>io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler</code>. If set, deserialization failure happening when deserializing values are delegated to this handler which may provide a fallback value.</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>graceful-shutdown</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not a graceful shutdown should be attempted when the application terminates.</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>poll-timeout</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The polling timeout in milliseconds. When polling records, the poll will wait at most that duration before returning records. Default is 1000ms</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>pause-if-no-requests</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the polling must be paused when the application does not request items and resume when it does. This allows implementing back-pressure based on the application capacity. Note that polling is not stopped, but will not retrieve any records when paused.</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can also pass any property supported by the <a href="https://vertx.io/docs/vertx-kafka-client/java/">Vert.x Kafka client</a> as attribute.</p>
</div>
</div>
<div class="sect2">
<h3 id="kafka-consumer-rebalance-listener"><a class="anchor" href="#kafka-consumer-rebalance-listener"></a>Consumer Rebalance Listener</h3>
<div class="paragraph">
<p>To handle offset commit and assigned partitions yourself, you can provide a consumer rebalance listener.
To achieve this, implement the <code>io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener</code> interface, make the implementing class a bean, and add the <code>@Identifier</code> qualifier.
A usual use case is to store offset in a separate data store to implement exactly-once semantic, or starting the processing at a specific offset.</p>
</div>
<div class="paragraph">
<p>The listener is invoked every time the consumer topic/partition assignment changes.
For example, when the application starts, it invokes the <code>partitionsAssigned</code> callback with the initial set of topics/partitions associated with the consumer.
If, later, this set changes, it calls the <code>partitionsRevoked</code> and <code>partitionsAssigned</code> callbacks again, so you can implement custom logic.</p>
</div>
<div class="paragraph">
<p>Note that the rebalance listener methods are called from the Kafka <em>polling</em> thread and must block the caller thread until completion.
That&#8217;s because the rebalance protocol has synchronization barriers, and using asynchronous code in a rebalance listener may be executed after the synchronization barrier.</p>
</div>
<div class="paragraph">
<p>When topics/partitions are assigned or revoked from a consumer, it pauses the message delivery and restarts once the rebalance completes.</p>
</div>
<div class="paragraph">
<p>If the rebalance listener handles offset commit on behalf of the user (using the <code>ignore</code> commit strategy), the rebalance listener <strong>must</strong> commit the offset synchronously in the <code>partitionsRevoked</code> callback.
We also recommend applying the same logic when the application stops.</p>
</div>
<div class="paragraph">
<p>Unlike the <code>ConsumerRebalanceListener</code>  from Apache Kafka, the <code>io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener</code> methods pass the Kafka <code>Consumer</code> and the set of topics/partitions.</p>
</div>
<div class="sect3">
<h4 id="_example_2"><a class="anchor" href="#_example_2"></a>Example</h4>
<div class="paragraph">
<p>In this example we set-up a consumer that always starts on messages from at most 10 minutes ago (or offset 0). First we need to provide
a bean that implements the <code>io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener</code> interface and is annotated with
<code>@Identifier</code>. We then must configure our inbound connector to use this named bean.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package inbound;

import io.smallrye.common.annotation.Identifier;
import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;
import org.apache.kafka.clients.consumer.Consumer;
import org.apache.kafka.clients.consumer.OffsetAndTimestamp;

import javax.enterprise.context.ApplicationScoped;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

@ApplicationScoped
@Identifier("rebalanced-example.rebalancer")
public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {

    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());

    /**
     * When receiving a list of partitions will search for the earliest offset within 10 minutes
     * and seek the consumer to it.
     *
     * @param consumer   underlying consumer
     * @param partitions set of assigned topic partitions
     */
    @Override
    public void onPartitionsAssigned(Consumer&lt;?, ?&gt; consumer,
        Collection&lt;org.apache.kafka.common.TopicPartition&gt; partitions) {
        long now = System.currentTimeMillis();
        long shouldStartAt = now - 600_000L; //10 minute ago

        Map&lt;org.apache.kafka.common.TopicPartition, Long&gt; request = new HashMap&lt;&gt;();
        for (org.apache.kafka.common.TopicPartition partition : partitions) {
            LOGGER.info("Assigned " + partition);
            request.put(partition, shouldStartAt);
        }
        Map&lt;org.apache.kafka.common.TopicPartition, OffsetAndTimestamp&gt; offsets = consumer
            .offsetsForTimes(request);
        for (Map.Entry&lt;org.apache.kafka.common.TopicPartition, OffsetAndTimestamp&gt; position : offsets.entrySet()) {
            long target = position.getValue() == null ? 0L : position.getValue().offset();
            LOGGER.info("Seeking position " + target + " for " + position.getKey());
            consumer.seek(position.getKey(), target);
        }
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package inbound;

import io.smallrye.reactive.messaging.kafka.IncomingKafkaRecord;
import org.eclipse.microprofile.reactive.messaging.Acknowledgment;
import org.eclipse.microprofile.reactive.messaging.Incoming;

import javax.enterprise.context.ApplicationScoped;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

@ApplicationScoped
public class KafkaRebalancedConsumer {

    @Incoming("rebalanced-example")
    @Acknowledgment(Acknowledgment.Strategy.NONE)
    public CompletionStage&lt;Void&gt; consume(IncomingKafkaRecord&lt;Integer, String&gt; message) {
        // We don't need to ACK messages because in this example we set offset during consumer re-balance
        return CompletableFuture.completedFuture(null);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To configure the inbound connector to use the provided listener we either set the consumer rebalance listener&#8217;s name:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Or have the listener&#8217;s name be the same as the group id:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Setting the consumer rebalance listener&#8217;s name takes precedence over using the group id.</p>
</div>
</div>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <p>SmallRye Reactive Messaging is licensed until the terms of the Apache Software License 2.0</p>
  <p>Access the source code from the <a href="https://github.com/smallrye/smallrye-reactive-messaging">GitHub repository</a>.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
